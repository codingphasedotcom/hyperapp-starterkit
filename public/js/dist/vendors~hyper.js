(window["webpackJsonp"] = window["webpackJsonp"] || []).push([ [ "vendors~hyper" ], {
    "./node_modules/hyperapp/src/app.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return app; });\nvar globalInvokeLaterStack = []\n\nfunction app(props) {\n  var appState\n  var appView = props.view\n  var appActions = {}\n  var appEvents = {}\n  var appMixins = props.mixins || []\n  var appRoot = props.root || document.body\n  var element = appRoot.children[0]\n  var oldNode\n  var willRender\n\n  for (var i = 0; i <= appMixins.length; i++) {\n    var mixin = appMixins[i] ? appMixins[i](emit) : props\n\n    Object.keys(mixin.events || []).map(function(key) {\n      appEvents[key] = (appEvents[key] || []).concat(mixin.events[key])\n    })\n\n    initialize(appActions, mixin.actions)\n    appState = merge(appState, mixin.state)\n  }\n\n  requestRender(\n    (oldNode = emit("load", element)) === element && (oldNode = element = null)\n  )\n\n  return emit\n\n  function initialize(actions, withActions, lastName) {\n    Object.keys(withActions || []).map(function(key) {\n      var action = withActions[key]\n      var name = lastName ? lastName + "." + key : key\n\n      if (typeof action === "function") {\n        actions[key] = function(data) {\n          emit("action", { name: name, data: data })\n\n          var result = emit("resolve", action(appState, appActions, data))\n\n          return typeof result === "function" ? result(update) : update(result)\n        }\n      } else {\n        initialize(actions[key] || (actions[key] = {}), action, name)\n      }\n    })\n  }\n\n  function render(cb) {\n    element = patch(\n      appRoot,\n      element,\n      oldNode,\n      (oldNode = emit("render", appView)(appState, appActions)),\n      (willRender = !willRender)\n    )\n    while ((cb = globalInvokeLaterStack.pop())) cb()\n  }\n\n  function requestRender() {\n    if (appView && !willRender) {\n      requestAnimationFrame(render, (willRender = !willRender))\n    }\n  }\n\n  function update(withState) {\n    if (withState && (withState = emit("update", merge(appState, withState)))) {\n      requestRender((appState = withState))\n    }\n    return appState\n  }\n\n  function emit(name, data) {\n    return (appEvents[name] || []).map(function(cb) {\n      var result = cb(appState, appActions, data)\n      if (result != null) {\n        data = result\n      }\n    }), data\n  }\n\n  function merge(a, b) {\n    var obj = {}\n\n    for (var i in a) {\n      obj[i] = a[i]\n    }\n\n    for (var i in b) {\n      obj[i] = b[i]\n    }\n\n    return obj\n  }\n\n  function getKey(node) {\n    if (node && (node = node.data)) {\n      return node.key\n    }\n  }\n\n  function createElement(node, isSVG) {\n    if (typeof node === "string") {\n      var element = document.createTextNode(node)\n    } else {\n      var element = (isSVG = isSVG || node.tag === "svg")\n        ? document.createElementNS("http://www.w3.org/2000/svg", node.tag)\n        : document.createElement(node.tag)\n\n      if (node.data && node.data.oncreate) {\n        globalInvokeLaterStack.push(function() {\n          node.data.oncreate(element)\n        })\n      }\n\n      for (var i in node.data) {\n        setData(element, i, node.data[i])\n      }\n\n      for (var i = 0; i < node.children.length; ) {\n        element.appendChild(createElement(node.children[i++], isSVG))\n      }\n    }\n\n    return element\n  }\n\n  function setData(element, name, value, oldValue) {\n    if (name === "key") {\n    } else if (name === "style") {\n      for (var i in merge(oldValue, (value = value || {}))) {\n        element.style[i] = value[i] || ""\n      }\n    } else {\n      try {\n        element[name] = value\n      } catch (_) {}\n\n      if (typeof value !== "function") {\n        if (value) {\n          element.setAttribute(name, value)\n        } else {\n          element.removeAttribute(name)\n        }\n      }\n    }\n  }\n\n  function updateElement(element, oldData, data) {\n    for (var i in merge(oldData, data)) {\n      var value = data[i]\n      var oldValue = i === "value" || i === "checked" ? element[i] : oldData[i]\n\n      if (value !== oldValue) {\n        setData(element, i, value, oldValue)\n      }\n    }\n\n    if (data && data.onupdate) {\n      globalInvokeLaterStack.push(function() {\n        data.onupdate(element, oldData)\n      })\n    }\n  }\n\n  function removeElement(parent, element, data) {\n    if (data && data.onremove) {\n      data.onremove(element)\n    } else {\n      parent.removeChild(element)\n    }\n  }\n\n  function patch(parent, element, oldNode, node, isSVG, nextSibling) {\n    if (oldNode == null) {\n      element = parent.insertBefore(createElement(node, isSVG), element)\n    } else if (node.tag != null && node.tag === oldNode.tag) {\n      updateElement(element, oldNode.data, node.data)\n\n      isSVG = isSVG || node.tag === "svg"\n\n      var len = node.children.length\n      var oldLen = oldNode.children.length\n      var oldKeyed = {}\n      var oldElements = []\n      var keyed = {}\n\n      for (var i = 0; i < oldLen; i++) {\n        var oldElement = (oldElements[i] = element.childNodes[i])\n        var oldChild = oldNode.children[i]\n        var oldKey = getKey(oldChild)\n\n        if (null != oldKey) {\n          oldKeyed[oldKey] = [oldElement, oldChild]\n        }\n      }\n\n      var i = 0\n      var j = 0\n\n      while (j < len) {\n        var oldElement = oldElements[i]\n        var oldChild = oldNode.children[i]\n        var newChild = node.children[j]\n\n        var oldKey = getKey(oldChild)\n        if (keyed[oldKey]) {\n          i++\n          continue\n        }\n\n        var newKey = getKey(newChild)\n\n        var keyedNode = oldKeyed[newKey] || []\n\n        if (null == newKey) {\n          if (null == oldKey) {\n            patch(element, oldElement, oldChild, newChild, isSVG)\n            j++\n          }\n          i++\n        } else {\n          if (oldKey === newKey) {\n            patch(element, keyedNode[0], keyedNode[1], newChild, isSVG)\n            i++\n          } else if (keyedNode[0]) {\n            element.insertBefore(keyedNode[0], oldElement)\n            patch(element, keyedNode[0], keyedNode[1], newChild, isSVG)\n          } else {\n            patch(element, oldElement, null, newChild, isSVG)\n          }\n\n          j++\n          keyed[newKey] = newChild\n        }\n      }\n\n      while (i < oldLen) {\n        var oldChild = oldNode.children[i]\n        var oldKey = getKey(oldChild)\n        if (null == oldKey) {\n          removeElement(element, oldElements[i], oldChild.data)\n        }\n        i++\n      }\n\n      for (var i in oldKeyed) {\n        var keyedNode = oldKeyed[i]\n        var reusableNode = keyedNode[1]\n        if (!keyed[reusableNode.data.key]) {\n          removeElement(element, keyedNode[0], reusableNode.data)\n        }\n      }\n    } else if (element && node !== element.nodeValue) {\n      element = parent.insertBefore(\n        createElement(node, isSVG),\n        (nextSibling = element)\n      )\n      removeElement(parent, nextSibling, oldNode.data)\n    }\n\n    return element\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/hyperapp/src/app.js?');
    },
    "./node_modules/hyperapp/src/h.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return h; });\nvar i\nvar stack = []\n\nfunction h(tag, data) {\n  var node\n  var children = []\n\n  for (i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i])\n  }\n\n  while (stack.length) {\n    if (Array.isArray((node = stack.pop()))) {\n      for (i = node.length; i--; ) {\n        stack.push(node[i])\n      }\n    } else if (node != null && node !== true && node !== false) {\n      if (typeof node === "number") {\n        node = node + ""\n      }\n      children.push(node)\n    }\n  }\n\n  return typeof tag === "string"\n    ? {\n        tag: tag,\n        data: data || {},\n        children: children\n      }\n    : tag(data, children)\n}\n\n\n//# sourceURL=webpack:///./node_modules/hyperapp/src/h.js?');
    },
    "./node_modules/hyperapp/src/index.js": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        eval('/* harmony import */ var _h__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./h */ "./node_modules/hyperapp/src/h.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _h__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ "./node_modules/hyperapp/src/app.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _app__WEBPACK_IMPORTED_MODULE_1__["a"]; });\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/hyperapp/src/index.js?');
    }
} ]);